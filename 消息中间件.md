# 消息队列



## 消息中间件的优缺点

优点：异步、解耦、限流、路由

缺点：增加了系统复杂性



## 推与拉模式学习



消息中间件的主要功能是消息的**路由(Routing)**和**缓存(Buffering)**。



一种分类是推和拉 。

还有一种分类是 Queue 和 Pub/Sub 。

 





降低耦合性,提高系统性能。



消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行[分布式系统](https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F)的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。 ----------From baidu.com

## JMS

定义了一系列的接口规范，像是JDBC， 各大厂商遵从这个规范进行开发自己的消息中间件。

JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。 



### JMS元素

Provider提供方：服务提供者

Producer生产者：创建和发送JMS消息的客户端

Consumer消费者：接受JMS消息的客户端

Client客户端：生产或消费消息的应用&进程

Message消息：服务端与客户端之间的传输数据对象

Queue队列：包含待读取消息的准备区域

Topic主题：发布消息的分布机制



###消息类型

· MapMessage--一套名称-值对

· TextMessage--一个字符串对象

· ObjectMessage--一个序列化的 Java对象

· BytesMessage--一个未解释字节的数据流

· StreamMessage -- Java原始值的数据流

### 消息传递类型



JMS中定义了两种消息模型：点对点（point to point， queue）和发布/订阅（publish/subscribe，topic）。主要区别就是是否能重复消费。



####1）点对点模式

![](images/JMS/点对点模式.png)

a）在点对点通信模式中，应用程序由消息队列，发送方，接收方组成。每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时。 

b）特点：

* 每个消息只要一个消费者
* 发送者和接收者在时间上是没有时间的约束，也就是说发送者在发送完消息之后，不管接收者有没有接受消息，都不会影响发送方发送消息到消息队列中。
* 发送方不管是否在发送消息，接收方都可以从消息队列中去到消息（The receiver can fetch message whether it is running or not when the sender sends the message）
* 接收方在接收完消息之后，需要向消息队列应答成功

####2）发布/订阅模式

![](images\JMS\发布订阅模式.png)

a）在发布/订阅消息模型中，发布者发布一个消息，该消息通过topic传递给所有的客户端。该模式下，发布者与订阅者都是匿名的，即发布者与订阅者都不知道对方是谁。并且可以动态的发布与订阅Topic。Topic主要用于保存和传递消息，且会一直保存消息直到消息被传递给客户端。 

b）特点：

* 一个消息可以传递个多个订阅者（即：一个消息可以有多个接受方）
* 发布者与订阅者具有时间约束，针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。
* 为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息



### 两种模式的区别



#### 点对点模式

​	生产者发送一条消息到queue，一个queue可以有很多消费者，但是一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有 一个可用的消费者，所以Queue实现了一个可靠的负载均衡。

#### 发布订阅模式

​	发布者发送到topic的消息，只有订阅了topic的订阅者才会收到消息。topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到这个消息的拷贝。



## 2、ActiveMQ

### 2.1、原生的模式

####2.1.1、点对点模式

生产者：

```java
@Test
public void testActiveMQProducer() throws JMSException {
   //1.创建连接工厂
   ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.1.127:61616");
   //2.创建连接
   Connection connection = connectionFactory.createConnection();
   //3.启动连接
   connection.start();
   //4.获取session(会话对象)，参数1：是否启用事物 false代表自动提交 ;参数2：消息确认方式
   Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
   //5、创建队列对象
   Queue queue = session.createQueue("test-queue");
   //6、创建消息的生产者对象
   MessageProducer producer = session.createProducer(queue);
   //7、创建消息对象（文本消息）
   TextMessage textMessage = session.createTextMessage("It's dangerous!");
   //8、发送消息
   producer.send(textMessage);
   //9、关闭资源
   producer.close();
   session.close();
   connection.close();
}
```

消费者：

```java
@Test
public void testActiveMQConsumer() throws JMSException, IOException {
   //1.创建连接工厂
   ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.1.127:61616");
   //2.创建连接
   Connection connection = connectionFactory.createConnection();
   //3.启动连接
   connection.start();
   //4.获取session(会话对象)，参数1：是否启用事物 false代表自动提交 ;参数2：消息确认方式
   Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
   //5、创建队列对象
   Queue queue = session.createQueue("test-queue");
   //6、创建消息的消费者对象
   MessageConsumer consumer = session.createConsumer(queue);
    //7、创建消息监听器
   consumer.setMessageListener((message)->{
      TextMessage textMessage = (TextMessage) message;
      try {
         System.out.println("Content:" + textMessage.getText());
      } catch (JMSException e) {
         e.printStackTrace();
      }
   });
   //8、等待键盘输入（为了在资源关闭前获取消息，因为这是一个客户端程序）
   System.in.read();
   //9、关闭资源
   consumer.close();
   session.close();
   connection.close();
}
```

#### 2.1.2、发布/订阅模式

生产者：

```java
@Test
public void testTopicProducer() throws JMSException {
   //1.创建连接工厂
   ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.1.127:61616");
   //2.创建连接
   Connection connection = connectionFactory.createConnection();
   //3.启动连接
   connection.start();
   //4.获取session(会话对象)，参数1：是否启用事物 false代表自动提交 ;参数2：消息确认方式
   Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
   //5.创建Topic对象
   Topic topic = session.createTopic("test-topic");
   //6、创建消息的生产者对象
   MessageProducer producer = session.createProducer(topic);
   //7、创建消息对象（文本消息）
   TextMessage textMessage = session.createTextMessage("It's dangerous!");
   //8、发送消息
   producer.send(textMessage);
   //9、关闭资源
   producer.close();
   session.close();
   connection.close();
}
```

消费者：

```java
@Test
public void testTopicConsumer() throws JMSException, IOException {
   //1.创建连接工厂
   ConnectionFactory connectionFactory = new ActiveMQConnectionFactory("tcp://192.168.1.127:61616");
   //2.创建连接
   Connection connection = connectionFactory.createConnection();
   //3.启动连接
   connection.start();
   //4.获取session(会话对象)，参数1：是否启用事物 false代表自动提交 ;参数2：消息确认方式
   Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
   //5、创建队列对象
   Topic topic = session.createTopic("test-topic");
   //6、创建消息的消费者对象
   MessageConsumer consumer = session.createConsumer(topic);
   //7、创建消息监听器
   /*consumer.setMessageListener(new MessageListener() {
      @Override
      public void onMessage(Message message) {
         TextMessage textMessage = (TextMessage) message;
         try {
            System.out.println("Content:" + textMessage.getText());
         } catch (JMSException e) {
            e.printStackTrace();
         }
      }
   });*/
   consumer.setMessageListener((message)->{
      TextMessage textMessage = (TextMessage) message;
      try {
         System.out.println("Content:" + textMessage.getText());
      } catch (JMSException e) {
         e.printStackTrace();
      }
   });
   //8、等待键盘输入（为了在资源关闭前获取消息，因为这是一个客户端程序）
   System.in.read();
   //9、关闭资源
   consumer.close();
   session.close();
   connection.close();
}
```

注意：消息发布订阅模式，消费者必须在生产这发布消息之前开启，否则收不到消息，类似于广播。

### 2.2与springboot整合

[详情参见SpringBoot整合篇。](springboot整合篇.md)



## RabbitMQ







## ZeroMQ



## RocketMQ



### 什么是RocketMQ

​	RcoketMQ 是一款低延迟、高可靠、可伸缩、易于使用的消息中间件。具有以下特性：

1. 支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型
2. 在一个队列中可靠的先进先出（FIFO）和严格的顺序传递
3. 支持拉（pull）和推（push）两种消息模式
4. 单一队列百万消息的堆积能力
5. 支持多种消息协议，如 JMS、MQTT 等
6. 分布式高可用的部署架构,满足至少一次消息传递语义
7. 提供 docker 镜像用于隔离测试和云集群部署
8. 提供配置、指标和监控等功能丰富的 Dashboard



### 名词解释

**Producer**

​	消息生产者，生产者的作用就是将消息发送到MQ，生产者本身既可以生产消息，如读取文本消息等。也可以对外提供接口，由外部应用来调用接口，再由生产者将收到的消息发送到MQ。

**Producer Group**

​	生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。在这里可以不用关心，只要知道有这么一个概念即可。

**Consumer**

​	消息消费者，简单来说，消费MQ上的消息的应用程序就是消费者，至于消息是否进行逻辑处理，还是直接存储到数据库等，取决于业务需要。

**Consumer Group**

​	消费者组，和生产者类似，消费同一类消息的多个consumer实例组成一个消费者组。

**Topic**

​	Topic是一种消息的逻辑分类，比如说你有个订单类的消息，也有库存类的消息，那么就需要进行分类，一个是订单Topic存放订单相关的消息，一个是库存Topic存储库存相关的消息。

**Message**

​	Message是消息的载体。一个Message必须指定topic，相当于寄信的地址。Message还有一个可选的tag设置，一边消费端可以基于tag进行过滤消息。也可以添加额外的键值对，例如你需要一个业务key来查找broker上的消息，方便在开发期间诊断问题。

**Tag**

​	标签可以被认为是对Topic进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。

**Broker**

​	Broker是RocketMQ系统的主要角色，其实就是前面一直说的MQ。Broker接受来自生产者的消息，储存以及为消费者拉取消息的请求做好准备。

**Name Server**

​	Name Server 为 producer 和 consumer 提供路由信息。



## RocketMQ 架构



![RocketMQ架构](images/消息队列/RocketMQ架构图.png)



​	由这张图可以看到有四个集群，分别是NameServer集群、Broker集群、Producer集群和Consumer集群：

1. NameServer：类似注册中心，提供轻量级的服务发现和路由。每个NameServer记录完整的路由信息，提供等效的读写服务，并支持快速存储扩展。
2. Broker：通过提供轻量级的Topic和Queue机制来处理消息存储，同时支持（push）和拉（pull）模式以及主从结构的容错机制。
3. Producer：生产者，产生消息的实例，拥有相同Producer Group的Producer组成一个集群。
4. Consumer：消费者，接受消息进行消费的实例，拥有相同Consumer Group的Consumer组成一个集群。

简单说明一下图中箭头的含义，从Broker开始，Broker Master1和Broker Slave1是主从结构，他们之间会进行数据同步，即Date Sync。同时每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer中。

Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Broker Master建立长连接，且定时向Broker发送心跳。Producer只能将消息发送到Broker Master，但是，Consumer则不一样，他同时和提供Topic服务的Master和Slave建立长连接，既可以从Broker Master订阅信息，也可以从Broker Slave订阅消息。



#### RocketMQ 安装



#####下载

`wget http://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/4.5.0/rocketmq-all-4.5.0-bin-release.zip`

##### 解压

`unzip rocketmq-all-4.2.0-bin-release.zip -d /root/svr/rocketmq`



#### RocketMQ 集群部署模式

#### RocketMQ 单主部署

#### 生产者、消费者 Demo



[RocketMQ 实战之快速入门](https://www.jianshu.com/p/824066d70da8)



## Kafka

