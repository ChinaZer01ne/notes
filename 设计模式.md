# 设计模式

## 1、代理模式

1、特点

​	1）执行者、被代理人

​	2）对于被代理人来说，这件事情是一定要做的，但自己不想做或者没有时间做，找代理

​	3）需要获取到被代理人的个人资料

2、举例

​	1）租房中介

​	2）代办公积金

​	3）小秘

​	.....

3、代理模式更关心过程。

### 1）静态代理

```java
public class PersonProxy implements Person{
    //接收保存目标对象
    private Person target;
    public PersonProxy(Person target){
        this.target=target;
    }

    public void work() {
        System.out.println("执行方法前...");
        target.work();//执行目标对象的方法
        System.out.println("执行方法后...");
    }
}
```



### 2）动态代理

```java
package design.pattern.proxy;

import java.lang.reflect.Proxy;

public class ProxyFactory {
    private Object target;
    public ProxyFactory(Object o){
        target = o;
    }

    public Object getProxyInstance(){
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), (proxy, method, args) -> {	//类加载器可以是任何类的加载器
            System.out.println("执行方法前");
            Object value = method.invoke(target,args);	
            System.out.println("执行方法后");
            return value;	//如果代理方法有返回值，此处必须有返回值，如果代理方法没返回值，此处可以随意返回
        });
    }
}
```

### 3）JDK代理的原理

​	1、拿到被代理对象的引用，获取她的接口

​	2、JDK代理重新生成一个类，同时实现你给的代理对象所实现的接口

​	3、拿到代理对象

​	4、重新动态生成一个字节码

​	5、重新编译

​	代理对象持有InvocationHandler的引用，调用被代理对象的方法时，通过反射将Method对象传给InvocationHandler的invoke方法，此时可以在对象前后做一些事情了。

### 4）手动实现JDK动态代理

1、实现InvocationHandler

```java
package design.pattern.proxy.jdk;

import java.lang.reflect.Method;

public interface MyInvocationHandler {
    Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
```

2、实现Proxy

```java
package design.pattern.proxy.jdk;


import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class MyProxy {

    private  static final String ln ="\n";
    public static Object newProxyInstance(MyClassLoader loader,
                                          Class<?>[] interfaces,
                                          MyInvocationHandler h) throws IOException, NoSuchMethodException, ClassNotFoundException, IllegalAccessException, InvocationTargetException, InstantiationException {
        //1、生成源代码
        String proxySrc = generateSource(interfaces[0]);
        //2、将生成源代码输出到磁盘，保存为java文件
        String path = MyProxy.class.getResource("").getPath();
        File file = new File(path + "$Proxy0.java");

        try (FileWriter fw = new FileWriter(file)) {
            fw.write(proxySrc);
            fw.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
        //3、编译源代码，并且生成class文件
        JavaCompiler javaCompiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager standardFileManager = javaCompiler.getStandardFileManager(null, null, null);
        Iterable<? extends JavaFileObject> javaFileObjects = standardFileManager.getJavaFileObjects(file);

        JavaCompiler.CompilationTask task = javaCompiler.getTask(null, standardFileManager, null, null, null, javaFileObjects);
        task.call();
        standardFileManager.close();
        //4、将class文件中的内容动态加载到jvm中
        Class<?> proxyClass = loader.findClass("$Proxy0");
        Constructor<?> constructor = proxyClass.getConstructor(MyInvocationHandler.class);
        file.delete();
        //5、返回代理对象
        return constructor.newInstance(h);
    }
    private static String generateSource(Class<?> interfaces){
        StringBuffer src = new StringBuffer();
        src.append("package design.pattern.proxy.jdk;" + ln);
        src.append("import java.lang.reflect.Method;" + ln);
        src.append("public class $Proxy0 implements " + interfaces.getName()+ "{"+ ln);
        src.append("MyInvocationHandler h;" + ln);
        src.append("public $Proxy0(MyInvocationHandler h){this.h=h;}" + ln);

        for (Method method : interfaces.getMethods()){
            src.append("@Override" + ln);
            src.append("public  " + method.getReturnType() + " " + method.getName() + "(){" + ln);
            src.append("try{" + ln);
            src.append("Method m = " + interfaces.getName() + ".class.getMethod(\""+ method.getName()+"\",new Class[]{});" + ln);
            src.append("this.h.invoke(this,m,null);" + ln);
            src.append("}catch(Throwable t){ t.printStackTrace();}" + ln);
            if (!method.getReturnType().equals("void")){
                src.append("return 1;");
            }
            src.append("}" + ln);
        }

        src.append("}");
        return src.toString();
    }
}
```

3、实现ClassLoader

```java
package design.pattern.proxy.jdk;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class MyClassLoader extends ClassLoader {

    private File baseDir;
    public MyClassLoader(){
        String basePath = MyClassLoader.class.getResource("").getPath();
        baseDir = new File(basePath);
    }
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        String className = MyClassLoader.class.getPackage().getName() + "." + name;
        if (baseDir != null){
            File file = new File(baseDir, name.replaceAll("\\.", "/") + ".class");
            if (file.exists()){
                FileInputStream in = null;
                ByteArrayOutputStream byteArrayOutputStream = null;
                try {
                    in = new FileInputStream(file);
                    byteArrayOutputStream = new ByteArrayOutputStream();
                    byte[] buff = new byte[1024];
                    int len;
                    while ((len = in.read(buff) )!= -1){
                        byteArrayOutputStream.write(buff, 0 ,len);
                    }
                    //加载到虚拟机
                    return defineClass(className, byteArrayOutputStream.toByteArray(), 0, byteArrayOutputStream.size());
                }catch (Exception e){
                    e.printStackTrace();
                }finally {
                    if (null != in){
                        try {
                            in.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                    if (null != byteArrayOutputStream){
                        try {
                            byteArrayOutputStream.close();
                        } catch (IOException e) {
                            e.printStackTrace();
                        }
                    }
                    file.delete();
                }
            }
        }
        return null;
    }
}
```

5、代理对象

```java
package design.pattern.proxy.jdk;

import design.pattern.proxy.Person;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class PersonProxy implements MyInvocationHandler {

    private Person target;

    public PersonProxy(Person person){
        this.target = person;
    }

    public Object getInstance() throws IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        return MyProxy.newProxyInstance(new MyClassLoader(), target.getClass().getInterfaces(),this);
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("执行方法前");
        method.invoke(target, args);
        System.out.println("执行方法后");
        return null;
    }
}
```

6、测试类

```java
package design.pattern.proxy;

import design.pattern.proxy.jdk.CustomMeiPo;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;

public class ProxyTest {
    public static void main(String[] args) throws IOException, ClassNotFoundException, NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {

        Person person =(Person) new PersonProxy(new Boy()).getInstance();
        person.findLove();
    }
}

```

