# 分布式事务



##概念

* 分布式事务就是将多个节点的事务看成一个整体处理
* 分布式事务由事务参与者、资源服务器、事务管理器等组成
* 常见的分布式事务的例子：支付、下订单等



##2pc、3pc

https://zhuanlan.zhihu.com/p/35298019



## Spring JMS事务



### 原生事务



### 外部事务（JmsTransactionManager）



## Spring事务

### 原生事务



### 外部事务（JTA）



* 



## Spring分布式事务



### JTA管理多个数据源

**强一致性事务**

JTA事务管理的弊端：

- 两阶段提交
- 事务时间太长，锁数据的时间太长
- 低性能，低吞吐量
- 只适用于单个服务内



例子：



```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jta-atomikos</artifactId>
</dependency>
```

场景：

MQ + DB 多数据源的事务（注解）

```java
@Transactional
@Override
@JmsListener(destination = "customer:msg1:create")
public void saveAndSend(String msg){

    Transaction transaction = new Transaction();
    transaction.setName("by listener in annotation. msg: " + msg);
    transaction.setVersion("by listener in annotation. msg: " + msg);
    transactionMapper.insert(transaction);

    log.info("Get msg: {}",msg);
    String reply = "Reply- in annotation : " + msg;
    jmsTemplate.convertAndSend("customer:msg:reply",reply);

    if (msg.contains("error")){
        throw new IllegalArgumentException();
    }
}
```

MQ + DB 多数据源的事务（非注解）

```java

@Autowired
private PlatformTransactionManager transactionManager;


@Override
public void saveAndSendInCode(String msg){

    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    def.setTimeout(15);
    TransactionStatus status = transactionManager.getTransaction(def);

    try {

        Transaction transaction = new Transaction();
        transaction.setName("by listener in annotation. msg: " + msg);
        transaction.setVersion("by listener in annotation. msg: " + msg);
        transactionMapper.insert(transaction);

        log.info("Get msg: {}",msg);
        String reply = "Reply- in code ：" + msg;
        jmsTemplate.convertAndSend("customer:msg:reply",reply);
        if (msg.contains("error")){
            transactionManager.rollback(status);
        }
        transactionManager.commit(status);
    }catch (Exception e){
        transactionManager.rollback(status);
    }

}
```





### 不使用JTA





MQ 和 DB 的分布式事务

1. Start messaging transaction
2. Receive message
3. Start database transaction
4. Update database
5. Commit database transaction
6. Commit messaging transaction



​	问题出现在第6步，当第6步出现错误，因为第5步数据库已经提交，导致无法回滚,数据不一致



* XA与最后资源博弈

* 共享资源

* 最大努力一次提交

  * 依次提交事务
  * 可能出错
  * 通过AOP或Listener实现事务的直接同步

* 链式事务

  如果是在提交过程中出现了数据库宕机的情况,也是有可能出现数据不一致的情况

  ```java
  //链式事务实现分布式事务
  @Bean
  public PlatformTransactionManager userTansactionManager(){
      DataSourceTransactionManager userTM = new DataSourceTransactionManager(userDataSource());
      DataSourceTransactionManager orderTM = new DataSourceTransactionManager(orderDataSource());
      
      ChainedTransactionManager chainedTransactionManager = new ChainedTransactionManager(userTM,orderTM);
      return chainedTransactionManager;
  }
  ```





### 选择

* MQ-DB：最大努力一次提交 + 重试
* 多个DB：链式事务管理
* 多个数据源：链式事务、或其他事务同步方式





## 实现

多实例分布式事务

### 消息驱动

通过触发事件，将流程的各个操作串联起来

### 事件溯源（Axon、Saga 感觉有点难）

* 事件作为一等数据保存
* 统一的事件管理器和接口，数据更新都由事件产生
* 数据库中数据的当前状态根据事件的聚合产生
* 聚合数据可以保存在数据库中、可以根据事件重新生成



### TCC

try-confirm-cancel

* 借鉴XA的统一资源管理，又不是两阶段提交
* 不同资源之间没有锁，事务过程数据没有锁、没有隔离
* 出错时可能多次调用Confirm/Cancel方法，以及顺序无法保证





### 微服务系统的分布式事务实现

* 事务同步
* 重试和幂等性
* Try-Confirm/Cancel的思想设计业务流程
* 根据微服务系统的架构具体情况具体分析