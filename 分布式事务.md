# 分布式事务



##概念

* 分布式事务就是将多个节点的事务看成一个整体处理
* 分布式事务由事务参与者、资源服务器、事务管理器等组成
* 常见的分布式事务的例子：支付、下订单等





## 分布式事务实现模式

* 消息驱动模式：Message Driven
  * 使用消息队列控制整个流程
* 事件溯源模式：Event Sourcing
  * EventStore
* TCC模式：Try-Confirm-Cancel





### 消息驱动的分布式事务



#### 购票案例：

![](images/分布式事务/消息驱动分布式事务.png)



#### 正常流程：

![](images/分布式事务/购票案例业务流程.png)



#### 异常流程：

锁票失败：

![](images/分布式事务/购票案例异常流程.png)

扣费失败：

![](images/分布式事务/购票扣费失败.png)

#### 异常订单处理

* 定时任务处理异常订单：1.未被处理完的 2.虽然被处理但未被标记为已完成
* 解锁票、撤销交票
* 对于余额之类的重要数据，可能使用人工处理



#### 实现锁票的安全性

* 利用@JmsLIstener设置一个消费者，不适用于多实例
* 使用事务和数据库锁的特性
* 分布式锁



#### 系统错误的处理

* 方法1：将出错未处理的消息写到失败队列，进行相应的回滚操作
* 方法2：通过定时任务检查超时订单，对未完成的订单自动回滚（比较推荐）
* 方法3：保存出错消息，人工处理





## 幂等性

* 幂等操作：任意多次执行所产生的影响，与一次执行的影响相同
* 方法的幂等性：使用同样的参数调用一个方法多次，与调用一次结果相同
* 接口的幂等性：接口被重复调用，结果一致



### 微服务接口的幂等性：

如：消息的重试、网关调用失败重试

* 重要性：经常需要通过重试实现分布式事务的最终一致性
* Get方法不会对系统产生副作用、天然幂等
* POST、PUT、DELETE方法的实现需要满足幂等性







##2pc、3pc

https://zhuanlan.zhihu.com/p/35298019



## Spring JMS事务



### 原生事务



### 外部事务（JmsTransactionManager）



## Spring事务

### 原生事务



### 外部事务（JTA）



* 



## Spring分布式事务



### JTA管理多个数据源

**强一致性事务**

JTA事务管理的弊端：

- 两阶段提交
- 事务时间太长，锁数据的时间太长
- 低性能，低吞吐量
- 只适用于单个服务内



例子：



```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jta-atomikos</artifactId>
</dependency>
```

场景：

MQ + DB 多数据源的事务（注解）

```java
@Transactional
@Override
@JmsListener(destination = "customer:msg1:create")
public void saveAndSend(String msg){

    Transaction transaction = new Transaction();
    transaction.setName("by listener in annotation. msg: " + msg);
    transaction.setVersion("by listener in annotation. msg: " + msg);
    transactionMapper.insert(transaction);

    log.info("Get msg: {}",msg);
    String reply = "Reply- in annotation : " + msg;
    jmsTemplate.convertAndSend("customer:msg:reply",reply);

    if (msg.contains("error")){
        throw new IllegalArgumentException();
    }
}
```

MQ + DB 多数据源的事务（非注解）

```java

@Autowired
private PlatformTransactionManager transactionManager;


@Override
public void saveAndSendInCode(String msg){

    DefaultTransactionDefinition def = new DefaultTransactionDefinition();
    def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);
    def.setTimeout(15);
    TransactionStatus status = transactionManager.getTransaction(def);

    try {

        Transaction transaction = new Transaction();
        transaction.setName("by listener in annotation. msg: " + msg);
        transaction.setVersion("by listener in annotation. msg: " + msg);
        transactionMapper.insert(transaction);

        log.info("Get msg: {}",msg);
        String reply = "Reply- in code ：" + msg;
        jmsTemplate.convertAndSend("customer:msg:reply",reply);
        if (msg.contains("error")){
            transactionManager.rollback(status);
        }
        transactionManager.commit(status);
    }catch (Exception e){
        transactionManager.rollback(status);
    }

}
```





### 不使用JTA





MQ 和 DB 的分布式事务

1. Start messaging transaction
2. Receive message
3. Start database transaction
4. Update database
5. Commit database transaction
6. Commit messaging transaction



​	问题出现在第6步，当第6步出现错误，因为第5步数据库已经提交，导致无法回滚,数据不一致



* XA与最后资源博弈

* 共享资源

* 最大努力一次提交

  * 依次提交事务
  * 可能出错
  * 通过AOP或Listener实现事务的直接同步

* 链式事务

  如果是在提交过程中出现了数据库宕机的情况,也是有可能出现数据不一致的情况

  ```java
  //链式事务实现分布式事务
  @Bean
  public PlatformTransactionManager userTansactionManager(){
      DataSourceTransactionManager userTM = new DataSourceTransactionManager(userDataSource());
      DataSourceTransactionManager orderTM = new DataSourceTransactionManager(orderDataSource());
      
      ChainedTransactionManager chainedTransactionManager = new ChainedTransactionManager(userTM,orderTM);
      return chainedTransactionManager;
  }
  ```





### 选择

* MQ-DB：最大努力一次提交 + 重试
* 多个DB：链式事务管理
* 多个数据源：链式事务、或其他事务同步方式





## 实现

多实例分布式事务

### 消息驱动

通过触发事件，将流程的各个操作串联起来

### 事件溯源（Axon、Saga 感觉有点难）

* 事件作为一等数据保存
* 统一的事件管理器和接口，数据更新都由事件产生
* 数据库中数据的当前状态根据事件的聚合产生
* 聚合数据可以保存在数据库中、可以根据事件重新生成



### TCC

try-confirm-cancel

* 借鉴XA的统一资源管理，又不是两阶段提交
* 不同资源之间没有锁，事务过程数据没有锁、没有隔离
* 出错时可能多次调用Confirm/Cancel方法，以及顺序无法保证





### 微服务系统的分布式事务实现

* 事务同步
* 重试和幂等性
* Try-Confirm/Cancel的思想设计业务流程
* 根据微服务系统的架构具体情况具体分析