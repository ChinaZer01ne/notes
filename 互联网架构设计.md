# 互联网架构设计



## 高可用设计手段



### 什么是高可用

​	通常指，通过设计来减少系统不能提供服务的时间。比如`7*24`表示一周七天，一天24小时不间断服务。



### 微服务高可用设计手段

* 服务冗余
* 无状态化
* 负载均衡
* 幂等设计
* 超时机制
* 异步化设计
* 服务限流降级熔断
* 数据复制/缓存/Sharding
* 架构拆分、服务治理
* 服务监控
* 服务分级



## 高并发设计阶段



### 什么是高并发

[高并发场景解决方案](高并发场景解决方案.md)



### 高并发关注点

* 吞吐量（Throughput）
* 响应延迟（Response Delay）



### 性能优化目标

* 缩短响应时间
* 提高并发数（增加吞吐量）
* 让系统处于合理状态



### 优化手段

* 空间换时间
  * 系统时间是瓶颈
  * 例如：缓存复用计算结果，降低时间开销，因为CPU时间较内存容量更加珍贵
* 时间换空间
  * 例如：网络传输是瓶颈，使用系统时间换取传输的空间，使用HTTP的gzip压缩算法
  * 例如：App的请求分类接口，使用版本号判断哪些数据更新了，只下载更新的数据
* 找到系统瓶颈
  * 分析系统业务流程，找到关键路径并分解优化
  * 例如：一个服务集群4万的QPS，调用量前5的接口贡献了3.5万的QPS
  * 对关键路径的代码优化收益最大，当然系统剩下的部分也不能忽视，比如剩下5千QPS的接口，若性能有问题也可能把整体服务性能拖垮



​	调用了多少RPC接口；载入多少数据；使用什么算法；非核心流程能否异步化，没有数据依赖的逻辑能否并行执行。



### 优化层次

* 架构设计层次
  * 拆分，微服务化
  * 分库分表，读写分离，数据分片
  * 无状态化设计，动态水平弹性扩展
  * 调用链路梳理，热点数据尽量靠近用户
  * 分布式Cache、多级多类型缓存
  * 容量规划
  * 提前拒绝，保证柔性可用
* 算法逻辑层次
  * 空间换时间
  * 时间换空间
* 代码优化层次
  * 循环遍历是否合理高效，不要在循环里调RPC接口、查询分布式缓存、执行SQL等
    * 先调批量接口组装好数据，再循环处理
  * 代码逻辑避免生成过多对象或无效对象
    * 输出Log时的log级别判断，避免new无效对象
  * ArrayList、HashMap初始容量设置是否合理
    * 扩容代价
  * 对数据对象是否合理重用，比如通过RPC查到的数据能复用则必须复用
  * 根据数据访问特性选择合适的数据结构，比如读多写少，考虑CopyOnWriteArrayList
  * 拼接字符串的时候是使用String相加还是StringBuilder进行append（再StringBuilder的容量预分配的情况下，StringBuilder的性能比String相加性能高15倍左右）
  * 是否正确初始化数据。有些全局共享的数据，饿汉式模式，在用户访问之前先初始化好
  * 数据库见表语句能尽量小的数据结构
    * 表示状态的字段，如果状态值再255以内使用`unsigned tinyint`，IP使用int而非varchar
  * 使用enum的场景使用tinyint替代，enum扩展需要改表
  * 避免使用select * 查询数据，只查询需要的字段，避免浪费数据IO、内存、CPU、网络传输
  * 分析查询场景建立合适的索引，分析字段的可选择性，索引长度，对长的varchar使用前缀索引
  * 字段尽量为Not NULL类型，Mysql手册说明允许NULL的字段需要额外的存储空间去处理NULL，并且很难查询优化
  * 目的为了降低服务器CPU使用率、IO流量、内存占用、网络小号，降低响应时间



​	局部性原理：例如二维数组的按行遍历和按列遍历，前者比后者快20倍。按行遍历符合局部性原理，CPU多级缓存命中率高。



## 服务无状态化设计与实践



### 什么是无状态化

* 冗余部署的多个模块（进程）完全对等
* 请求提交到冗余部署的任一模块，处理结果完全一样
* 模块不存储业务的上下文信息
* 仅根据每次请求携带数据进行相应的业务逻辑处理



### 目的

* 快速扩容服务
* 弹性缩容服务



### 案例

* 用户Session数据
  * 登陆方式
    * 用户名 + 密码
    * 手机号 + 验证码
  * 登陆成功
    * 生成用户凭证（session）
    * AES（UID + Timestmap + 校验码）
* 用户Session数据存放在哪里？
  * 网关层
* 用户Session数据如何存放？
  * 直接存放网关层
    * 单点
      * 需要水平扩展达到高可用
    * 网关层有状态变化
  * 存在外部存储
    * 网关层无状态化
    * Session数据高可用



## 负载均衡设计与实践



### 负载均衡系统

* 硬件
  * F5
  * A10
  * Radware
* 软件
  * LVS
    * 4层
  * Nginx
    * 7层
  * HaProxy
    * 4层或7层



### 负载均衡算法

 * Dubbo LoadBlalance

    * Random
       * 随机，按权重设置随机概率
   * RoundRobin
     * 轮询，按约定后的权重设置轮询比率
   * ConsistentHash
     * 一致性Hash，相同参数的请求总是发到同一提供者

   ......



### 广义负载均衡

* 完整的故障处理恢复机制
  * 故障自动发现
  * 故障服务自动摘除
    * 服务熔断机制
  * 请求自动重是
  * 服务恢复自动发现



## 幂等设计



###什么是幂等

​	客户端以相同的方式重复调用服务就应该产生相同的结果。

 * 请求层面
    * 保证请求重复执行和执行一次结果相同
    * f···f(f(x)) = f(X)
       * x是参数
       * f是执行函数/方法
* 业务层面
  * 同一用户不重复下单
  * 商品不超买
  * MQ消费端去重



### 为什么需要幂等性

​	请求重试：

​	例如：下订单的时候，点击支付之后没反应，就多点击了几次。在这种情况下，如果接口不是幂等性，那么就会出现重复支付问题。



### 幂等范围

* 读/写请求层面
  * 读请求不会对数据造成改变，不需要做幂等
  * 写请求，可能会对数据造成改变，可能需要做幂等
* 架构层面
  * 哪些层会对数据造成改变
    * 反向代理层？不会
    * 网关层？不会
    * 业务逻辑层？不会
    * 数据访问层？会



### 数据访问层的幂等



* CRUD
  * Create/insert
    * 业务主键代替自增主键
  * Read/select
  * Update
    * Update user set age = 18 where uid = 58;   幂等的；绝对值的修改是幂等的。
    * Update user set age++ where uid = 58;  非幂等的；相对值的修改不是幂等的。可以先查询然后转化为绝对值的修改。
  * Delete
    * Delete from user where uid = 58; 幂等的；绝对值的删除是幂等的。
    * Delete from user where uid in bottom 10; 非幂等的；相对值的删除不是幂等的，可以先查询然后转化为绝对值的删除。



### 业务层面幂等

* 冗余部署多个进程
  * 存在并发消费的可能性
  * 并发转变成串行消费
* 本质
  * 分布式锁的问题



## 分布式锁



### 什么是分布式锁

* 分布式环境下，锁定全局唯一资源
  * 请求处理串行化
  * 实际表现互斥锁



### 为什么使用分布式锁

* 交易订单锁定
  * 防止重复下单
  * 解决业务层幂等问题
* MQ消息消费幂等性
  * 发送消息重复
  * 消息消费端去重
  * 比如手机提现
* 在用户对商品下单后，订单状态为待支付，在某一时刻用户正在对该订单做支付操作，商家对该订单进行改价操作
  * 状态的修改行为需要做串行处理，避免出现数据错乱



### 基于Redis分布式锁

* 基于Redis分布式锁方案
  * 特性：唯一线程串行处理
  * 实现方式
    * Redis Setnx
  * 存在问题
    * 锁时间不可控
      * 无法续租期
    * 单点问题
      * 单实例存在进程一旦死掉，会彻底阻塞业务流程
      * 主从方式，主从数据异步，会存在锁失效问题
  * 官方建议
    * Redis本身建议使用Redlock算法来保证，但是问题是需要至少三个Redis主从实例来完成，维护成本高。Redlock等同于自己实现简单的一致性协议



### 高可用分布式锁设计目的

* 设计目标
  * 强一致性
  * 服务高可用、系统稳健
  * 锁自动续约及其自动释放
  * 代码高度抽象业务接入极简
  * 可视化管理后台，监控及管理



### 高可用分布式锁设计方案对比

|            | redis  |    zookeeper    |    etcd     |
| :--------: | :----: | :-------------: | :---------: |
| 一致性算法 |   无   |      paxos      |    raft     |
|    CAP     |   AP   |       CP        |    CP/AP    |
|   高可用   |  主从  |     N+1可用     |             |
|  接口类型  | 客户端 |     客户端      |  http/grpc  |
|    实现    | setNX  | createEphemeral | restful API |



* 由于Redis无法保证数据一致性

* Zookeeper对锁实现使用创建临时节点和watch机制，执行效率、扩展能力、社区活跃度等方面低于etcd

* 选择基于etcd实现



### 分布式锁存储选型

* etcd
  * 简单KV
  * 强一致
  * 高可用
    * 无单点
  * 数据高可靠
    * 持久化



### 分布式锁整体方案

* 分布式Client + etcd

  * Client TTL模式
    * ClientA -> etcd -> ("key" , "ttl", "value", "uuid")
    * ClientA -> etcd -> ("key" , "ttl", "value", "uuid")
    * ClientA拿锁成功，ClientB拿锁失败
    * A服务需要对etcd保持后台心跳线程
      - 比如key的租期为10ms，后台心跳线程为3ms，心跳线程负责在拿到key之后，没3ms cas唯一凭证uuid
  * Server TTL模式






###基于ZK分布式锁